<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JavaScriptDesignPatterns</title>
</head>
<body>
<div id="box1">hello1</div>

</body>
<!--<script src="js/YU.js"></script>-->
<script>
    /*
     Flyweight  享元模式

     Flyweight 享元模式是一种经典的经构型解决方案，用于优化重复，缓慢及数据共享较低的代码。它旨在通过与相关的对象共享尽可能多的数据来减少应用程序中内存的使用。

     Flyweight数据共享会涉及获取多个对象使用的若干相似对象或数据结构，以及将这些数据放到一个单一的外部对象中。我们可以将该对象传递给信赖这些数据的对象，而不是在每一个对象都存储相同的数据。

     我的理解是：在一个大型系统中，如果从头到尾执行功能，要占据1000M内存，可能主要用于缓存变量等功能。如果我们可以把他按相同属性或者功能分块，比如划分为内外两块，当内部功能执行完毕后，把执行结果保存起来，释放内存，然后再执行外部功能，利用内部已经存好的变量。这些每次执行只占用了500M内存，节省了一半的内存。或者还可以细分为4块，及更多，如果需要的话。
     这很类似数组分块函数的作用。
     */

    //示例一：图书馆系统：
    /*

     假设未使用享元模式时：一本书的状态包含：id,title,author,ISBN,checkoutDate,checkoutMember,availability。当使用数以千计的书籍对象时，要用1000M内存。
     使用了享元模式时：一本书的状态包含：内部状态id,title,author,ISBN,外部状态checkoutDate,checkoutMember,availability。当使用数以千计的书籍对象时，先检查书的内部状态，返回书的内部状态，然后再检查书的外部状态，要用500M内存。
     */


    //示例二：冒泡事件
    /*
     假设未使用享元模式时：我们在1000个按钮上分别绑定了一个事件，绑定了1000个事件。占用1000个事件的内存。
     使用了享元模式时：我们在1000个按钮的父元素向上绑定一个事件，总共绑定了1个事件，占用了1个事件的内存。通过target对目标对象按钮进行操作。
     */


</script>
</html>