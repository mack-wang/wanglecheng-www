<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
<script>
    /*
     Javascript语言特有的"链式作用域"结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，但是子对象的所有变量，对父对象都是不可见的。
    */

    //一、函数内部可以访问全局变量
    var name1 = '爷爷';
    function fun1() {
        console.log(name1);
    }
    fun1();//爷爷


    //二、函数外部无法访问函数内部的局部变量

    function fun2() {
        var name2 = '爸爸1';
    }
    fun2();
//    console.log(name2);//未定义


    //三、函数内部可以定义全局变量，把var关键字删除即可
    function fun3() {
        name3 = '爸爸2';
    }
    fun3();
    console.log(name3);//爸爸

    //三、函数可以嵌套函数返回父函数的私有变量，使其能被外部访问到私有变量
    //闭包示例
    var name4 = '爸爸4';
    function fun4() {
       var name4= '爸爸3';//如果把这句注释掉，则name4会沿着作用域链向上一级一级的寻找到window下的name4
        function fun5() {//此处定义的就是闭包
            return name4;//fun5()内部未定义name4，所以向作用域链的上一级寻找var声明的name4
        }

        return fun5;//此处返回的就是闭包
    }
    var fun6 = fun4();
    console.log(fun6());//爸爸3

    /*

     各种专业文献上的"闭包"（closure）定义非常抽象，很难看懂。
     我的理解是，闭包就是能够读取其他函数内部变量的函数。

     由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，
     因此可以把闭包简单理解成"定义在一个函数内部的函数"。
     所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。


     闭包的概念

     「官方」的解释
     「闭包」，是指拥有多个变量和绑定了这些变量的环境的
     表达式（通常是一个函数），因而这些变量也是该表达式
     的一部分。
     但不要咬文嚼字，我们简单的可以理解为
     闭包是个函数，而它「记住了周围发生了什么」。表现为由「一个函数」体中定义了「另个函数」
     function outer () {
     ...
     function inner () {
     ...
     }
     }

    */

    /*
     闭包的用途
     闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。

     怎么来理解这句话呢？请看下面的代码。

     　　function f1(){

     　　　　var n=999;

     　　　　nAdd=function(){n+=1}

     　　　　function f2(){
     　　　　　　 alert(n);
     　　　　 }

     　　　　return f2;

     　　}

     　　var result=f1();//我理解：result实际上就是f2()，只是一个alert(n)

     　　result(); // 999 结果n=999存在了内存中

     　　nAdd();//这里引用了上面的执行结果内存中的n，n+1=1000（假如内存中没有n,那么nAdd应该要报错，因为nAdd()中没有定义n的值）

     　　result(); // 1000  这里把n输出

     在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。

     为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。

     这段代码中另一个值得注意的地方，就是"nAdd=function(){n+=1}"这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。

     注意：
     1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

     2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

    */





</script>
</html>